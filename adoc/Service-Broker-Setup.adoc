// Start attribute entry list (Do not edit here! Edit in entities.adoc)
ifdef::env-github[]
:suse: SUSE
:product: {suse} Cloud Applications Platform
:version: 1.1
:rn-url: https://www.suse.com/releasenotes
:doc-url: https://www.suse.com/documentation/cloud-application-platform-1
:deployment-url: https://www.suse.com/documentation/cloud-application-platform-1/book_cap_deployment/data/book_cap_deployment.html
:caasp: {suse} Containers as a Service Platform
:caaspa: {suse} CaaS Platform
:ostack: OpenStack
:cf: Cloud Foundry
:scc: {suse} Customer Center
:azure: Microsoft Azure
:mysql: MySQL
:postgre: PostgreSQL
endif::[]
// End attribute entry list


[id='sec.service-broker']
== Service Broker Setup


[id='sec.service-broker.sidecar']
=== Setting up and Using a Service Broker Sidecar

We currently provide helm charts for two service brokers managing
access to MySQL (see <<sec.service-broker.mysql>>) and
PostgreSQL (<<sec.service-broker.postgresql>>) databases.

This document describes how to use these charts in the context of
a {product} cluster.


[id='sec.service-broker.sidecar-pre']
=== Prerequisites

- Helm must be configured. For more information, see the
  link:https://docs.helm.sh/using_helm/#quickstart[Helm documentation].
- A working {product} deployment.
- An Application Security Group (ASG) for applications to reach external databases. For more information, see the 
  link:http://docs.cloudfoundry.org/concepts/asg.html[CloudFoundry Documentation regarding application security groups].
+
For testing purposes use the following (insecure) security group:
+
[source,bash]
----
$ echo > "internal-services.json" '[{ "destination": "0.0.0.0/0", "protocol": "all" }]'
$ cf create-security-group internal-services-test internal-services.json
$ cf bind-running-security-group internal-services-test
$ cf bind-staging-security-group internal-services-test
----
+
If the ASG is applied later, running applications must be restarted to make use of the security group.


[id='sec.service-broker.mysql']
=== Deploying the MySQL chart

You need an external MySQL installation, with account credentials that allow
creating and deleting both databases and users.


[id='sec.service-broker.configure']
=== Configuring the Deployment

Create a values.yaml file (the rest of the document assumes it is called
`usb-config-values.yaml`) with the settings required for the install.  Use the
file below as a template, and modify the values to suit your installation.

[source,yaml]
----
env:
  # Database access credentials; the given user must have privileges to create
  # and delete both databases and users
  SERVICE_MYSQL_HOST: mysql.example.com
  SERVICE_MYSQL_PORT: 3306
  SERVICE_MYSQL_USER: mysql-admin-user
  SERVICE_MYSQL_PASS: mysql-admin-password

  # CAP access credentials
  CF_ADMIN_USER: admin
  CF_ADMIN_PASSWORD: changeme
  CF_DOMAIN: example.com

  # CAP internal certificate authorities
  # The SECRET_NAME can be obtained via the command line:
  # $ kubectl get pods --namespace $UAA_NAMESPACE -o jsonpath='{.items[*].spec.containers[?(.name=="uaa")].env[?(.name=="INTERNAL_CA_CERT")].valueFrom.secretKeyRef.name}'
  # CF_CA_CERT can be obtained via the command line:
  # $ kubectl get secret -n $SCF_NAMESPACE $SECRET_NAME -o jsonpath='{.data.internal-ca-cert}' | base64 -d
  CF_CA_CERT: |
    -----BEGIN CERTIFICATE-----
    MIIESGVsbG8gdGhlcmUgdGhlcmUgaXMgbm8gc2VjcmV0IG1lc3NhZ2UsIHNvcnJ5Cg==
    -----END CERTIFICATE-----

  # UAA_CA_CERT can be obtained with the command line:
  #   kubectl get secret -n $UAA_NAMESPACE $SECRET_NAME -o jsonpath='{.data.internal-ca-cert}' | base64 -d
  UAA_CA_CERT: |
    -----BEGIN CERTIFICATE-----
    MIIETm8gcmVhbGx5IEkgc2FpZCB0aGVyZSBpcyBubyBzZWNyZXQgbWVzc2FnZSEhCg==
    -----END CERTIFICATE-----

  SERVICE_TYPE: mysql # Optional

# The whole "kube" section is optional
kube:
  organization: cap # Docker registry organization
  registry:         # Docker registry access configuration
    hostname: "registry.suse.com"
    username: ""
    password: ""
----


[id='sec.service-broker.chart']
=== Deploy the Chart

When deploying the chart, a Kubernetes namespace to install the sidecar to is
required.  It may optionally be the same namespace as {product} is installed to,
though only one MySQL service may be deployed into a namespace at a time.

. Ensure that you have the SUSE helm chart repository available:
+
[source,bash]
----
$ helm repo add suse https://kubernetes-charts.suse.com/
----

. Install the helm chart:
+
[source,bash]
----
$ SIDECAR_NAMESPACE=mysql-sidecar
$ helm install suse/cf-usb-sidecar-mysql \
  --devel \
  --namespace ${SIDECAR_NAMESPACE} \
  --set "env.SERVICE_LOCATION=http://cf-usb-sidecar-mysql.${SIDECAR_NAMESPACE}:8081" \
  --values usb-config-values.yaml \
  --wait
----

. Wait for all the pods to be ready (Press `Ctrl+C` once all the pods are shown as fully ready):
+
[source,bash]
----
$ watch kubectl get pods --namespace=${SIDECAR_NAMESPACE}
----

. Confirm that the service has been added to your {product} installation:
+
[source,bash]
----
$ cf marketplace
----


[id='sec.service-broker.use']
==== Using the Service

To create a new service instance, use the {cf} command line client:

[source,bash]
----
$ cf create-service mysql default service_instance_name
----

The last argument, `service_instance_name`, is the desired name of the
service instance.

To bind the service instance to an application, use the `bind-service` subcommand:

[source,bash]
----
$ cf bind-service my_application my_service_instance_name
----


[id='sec.service-broker.postgresql']
=== Deploying the PostgreSQL chart

The PostgreSQL configuration is slightly different from the MySQL configuration;
the database-specific keys are named differently, and an additional key is
introduced:

[source,yaml]
----
env:
  # Database access credentials; the given user must have privileges to create
  # delete both databases and users
  SERVICE_POSTGRESQL_HOST: postgres.example.com
  SERVICE_POSTGRESQL_PORT: 5432
  SERVICE_POSTGRESQL_USER: pgsql-admin-user
  SERVICE_POSTGRESQL_PASS: pgsql-admin-password
  # The SSL connection mode when connecting to the database.  For a list of
  # valid values, please see https://godoc.org/github.com/lib/pq
  SERVICE_POSTGRESQL_SSLMODE: disable

  # CAP access credentials
  CF_ADMIN_USER: admin
  CF_ADMIN_PASSWORD: changeme
  CF_DOMAIN: example.com

  # CAP internal certificate authorities
  # The SECRET_NAME can be obtained via the command line:
  # $ kubectl get pods --namespace $UAA_NAMESPACE -o jsonpath='{.items[*].spec.containers[?(.name=="uaa")].env[?(.name=="INTERNAL_CA_CERT")].valueFrom.secretKeyRef.name}'
  # CF_CA_CERT can be obtained via the command line:
  # $ kubectl get secret -n $SCF_NAMESPACE $SECRET_NAME -o jsonpath='{.data.internal-ca-cert}' | base64 -d
  CF_CA_CERT: |
    -----BEGIN CERTIFICATE-----
    MIIESGVsbG8gdGhlcmUgdGhlcmUgaXMgbm8gc2VjcmV0IG1lc3NhZ2UsIHNvcnJ5Cg==
    -----END CERTIFICATE-----

  # UAA_CA_CERT can be obtained with the command line:
  #   kubectl get secret -n $UAA_NAMESPACE $SECRET_NAME -o jsonpath='{.data.internal-ca-cert}' | base64 -d
  UAA_CA_CERT: |
    -----BEGIN CERTIFICATE-----
    MIIETm8gcmVhbGx5IEkgc2FpZCB0aGVyZSBpcyBubyBzZWNyZXQgbWVzc2FnZSEhCg==
    -----END CERTIFICATE-----

  SERVICE_TYPE: postgres # Optional

# The whole "kube" section is optional
kube:
  organization: cap # Docker registry organization
  registry:         # Docker registry access configuration
    hostname: "registry.suse.com"
    username: ""
    password: ""
----

The command to install the Helm chart is also different in that it needs a
different host name for the service location:

[source,bash]
----
SIDECAR_NAMESPACE=pgsql-sidecar
$ helm install suse/cf-usb-sidecar-postgres \
  --devel \
  --namespace ${SIDECAR_NAMESPACE} \
  --set "env.SERVICE_LOCATION=http://cf-usb-sidecar-postgres.${SIDECAR_NAMESPACE}:8081" \
  --values usb-config-values.yaml \
  --wait
----


[id='sec.service-broker.remove-sidecar']
=== Removing Service Broker Sidecar Deployments

To correctly remove sidecar deployments, take the following actions in order:

. Unbind any applications using instances of the service, and delete those instances:
+
[source,bash]
----
$ cf unbind-service my_app my_service_instance
$ cf delete-service my_service_instance
----

. Install the link:https://github.com/SUSE/cf-usb-plugin/[CF-USB CLI plugin] for
the link:https://github.com/cloudfoundry/cli/[Cloud Foundry CLI]:
+
[source,bash]
$ cf install-plugin \
  https://github.com/SUSE/cf-usb-plugin/releases/download/1.0.0/cf-usb-plugin-1.0.0.0.g47b49cd-linux-amd64

. Configure the {cf} USB CLI plugin:
+
[source,bash]
$ cf usb-target https://usb.${DOMAIN}

. Remove the services:
+
[source,bash]
# See `env.SERVICE_LOCATION` configuration value when deploying the helm chart.
$ cf usb delete-driver-endpoint "http://cf-usb-sidecar-mysql.${SIDECAR_NAMESPACE}:8081"

. Delete Helm release from Kubernetes:
+
[source,bash]
$ helm list # Find the name of the helm deployment
$ helm delete --purge â€¦
